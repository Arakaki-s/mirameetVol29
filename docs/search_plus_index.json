{"./":{"url":"./","title":"はじめに","keywords":"","body":"mirameet vol.29_エグゼコム　現場で役立つ実践Vue.js!～ECサイトを作成してみる～ 事前準備 VSCodeインストール Dockerインストール 今回の流れ 以下内容についてハンズオンしていきます。 商品検索の共通ヘッダーを実装してみる（component） 商品検索画面の初期表示処理を実装してみる（created, mounted） 商品をカートに入れる機能を実装する（VueX） 商品の合計金額を自動で算出する（computed） 手順 ここに画像 環境構築①：デモアプリクローン 環境構築②：デモアプリの起動、動作確認 アプリケーションコード修正（商品検索画面） アプリケーションコード修正（商品詳細画面） アプリケーションコード修正（カート画面） 作成したコンテナの削除 "},"create_env_no1.html":{"url":"create_env_no1.html","title":"環境構築 1","keywords":"","body":"環境構築 その１ Django APIサーバーをDocker環境で準備 はじめに今回のハンズオンの環境構築を行いたいと思います。まずは、Vueの環境を立てる前にサーバーサイドとして使用するDjangoフレームワークを用いてAPIサーバーを準備します。 githubリポジトリにアクセス以下リンクよりデモアプリのあるGithubリポジトリにアクセスします。URL:https://github.com/miracleave-ltd/mirameetVol29 ソースコードダウンロードCodeボタンより、Zipファイルをダウンロードします。 ソースコード展開ダウンロードしたZipファイルを任意のフォルダに展開してください。※次の手順を進めるに当たり、展開されたフォルダをVSCodeで開くようお願いします。 サーバーの起動一度ローカルでサーバーを立ち上げましょう。4-1. Dockerのbuildと起動の確認コマンドをVSCodeのターミナル上から実施し、Dockerの起動を行います。以下イメージのように Creating ... done と表示されると成功 $ docker-compose up -d --build dockerが起動しているか以下のコマンドで確認してみましょう。 $ docker-compose ps Name Command State Ports -------------------------------------------------------------------------------------------------- mirameet_vol30_20220314_client_1 docker-entrypoint.sh node Up 0.0.0.0:8080->8080/tcp mirameet_vol30_20220314_server_1 python manage.py runserver ... Up 0.0.0.0:8040->8000/tcp state が Up となっていれば問題ありません。4-2. スーパーユーザーの作成以下コマンドを実施し、管理サイトにて使用するユーザー情報を作成します。 docker-compose run web python manage.py createsuperuser 設定する値はそれぞれ以下の通りです。 ユーザー名：admin メールアドレス：未設定（そのままEnter） パスワード：任意の値（単純すぎるものは警告が出ます）上記までの手順で、ブラウザに以下URLを入力することで画面を参照することが出来ます。 "},"create_env_no2.html":{"url":"create_env_no2.html","title":"環境構築 2","keywords":"","body":"環境構築 その2 Vue アプリケーションをDocker環境で準備 続いてVueアプリケーションの準備に移ります。 Vueの環境構築はecsiteディレクトリ直下をvscodeで開くように注意してください。vscodeが正常に動作しないことがあります。以下がecsiteディレクトリになります。 mirameetVol31.-main/client/ecsite Dockerコンテナに入ってnpm installを実行Vueプロジェクトに必要なパッケージをインストールするためにまずは下記のコマンドでDockerコンテナに入ります。 $ docker-compose exec client sh Dockerコンテナ内に入ったらnpmを使ってパッケージをインストールします。 /usr/src # npm install npmでvue/cliをインストールします。 /usr/src # npm install -g @vue/cli Vueアプリケーションサーバーをたてるnpmでパッケージインストールが完了したら引き続きDocker内で以下コマンドでVueアプリケーションを立てましょう。ビルドには少々時間がかかります。 /usr/src # npm run serve ブラウザから起動確認をしましょう。 2 の実装が完了したら以下のURLでブラウザ上から起動の確認を行ってください。url: http://localhost:8080 "},"component.html":{"url":"component.html","title":"アプリケーションコード修正(App.vue)","keywords":"","body":"アプリケーションコード修正(コンポーネント) 当手順では、以下の赤枠部分を実施します。 1.当画面に関連するソースファイル src\\App.vue←修正対象 src\\components\\Header.vue src\\router\\index.js 修正する前に一度、状況を確認してみましょう。 http://localhost:8080/ 画面としては何もない状態であることがわかったかと思います。 確認できたところで、あらためて修正をすすめていきましょう！ 2.src\\App.vueの修正 ヘッダーをインポートして画面に配置しよう。 src\\App.vue にヘッダー用のコンポーネントをインポートし、 画面上に配置します。 Ctrl+P(MACの場合Command+P) を押下してファイル検索を表示し、「App.vue」を開く ソースを以下のように修正してください。修正したら、ファイルを上書き保存してください。 修正前 export default { name: 'App', components: { } } 修正後 // Header.vueをインポート import Header from './components/Header' // components にHeader追加する export default { name: 'App', components: { Header } } 画面上部にヘッダーが実装できました。 vueファイルは主に ・templateタグ：html要素を記述する ・scriptタグ：javascriptの処理を記述する ・styleタグ：cssを記述する の三つのタグからなります。 これらを合わせて一つのコンポーネントとして作成し、 それら組み合わせて1つのページを作るのがVue.jsの大枠の考え方です。 コンポーネントを呼び出すにはまずscriptタグ内で呼び出すコンポーネントのvueファイルをインポートし、components要素内に使用するコンポーネント名を記載します。 その後templateタグ内で、呼び出すコンポーネント名をそのままタグとして記載してあげれば、その場所に子コンポーネントが挿入されます。 補足:ルーティングの説明 app.vueの以下の部分(Vue Router) Vue Routerとは、 Vue.jsを利用したSPA構築で、ルーティング制御をするための公式プラグインです src\\router\\index.js内に、アプリケーションのルーティングを記述しています。 import Vue from 'vue' import VueRouter from 'vue-router' import itemSearch from '../views/itemSearch.vue' import Cart from '../views/Cart.vue' import DetailView from '../views/detailView.vue' Vue.use(VueRouter) const routes = [ { path: '/', name: 'home', component: itemSearch }, { path: '/cart', name: 'cart', component: Cart }, { path: '/detail', name: 'detail', component: DetailView } ] const router = new VueRouter({ mode: 'history', base: process.env.BASE_URL, routes }) export default router pathに書かれたURLにアクセスすると、componentに設定されたページ内容を 「router-view」のエリアで表示します。 今回の場合は上記記述によって、ヘッダーは常に共通のものが表示、URLが変更されると 「router-view」の内容がそのURLに設定されたページを表示してくれます。 次の手順では、ヘッダー内の修正を行っていきます！ "},"header.html":{"url":"header.html","title":"アプリケーションコード修正(ヘッダー)","keywords":"","body":"アプリケーションコード修正(ヘッダー) 当手順では、以下の赤枠部分を実施します。 1.当画面に関連するソースファイル src\\components\\Header.vue←修正対象 修正する前に一度、状況を確認してみましょう。 http://localhost:8080/ 「大分類」から、何か選択した状態で「中分類」のリストをクリックしてみてください。 フィルタリング処理が実装されておらず、大分類を変更しても中分類リストの選択肢一覧に変更がないことが分かったかと思います。 確認できたところで、あらためて修正をすすめていきましょう！ 2.src\\components\\Header.vueの修正 computed を使ってフィルタリング処理を実装しよう。 Ctrl+P(MACの場合Command+P) を押下してファイル検索を表示し、「Header.vue」を開く Ctrl+F(MACの場合Command＋F) で検索欄を表示し、「filterdMediumCategory」内にフィルタリング処理を記述する。中分類リストの選択肢内容を、大分類の選択値に基づいて動的にフィルタリング処理をかけてみましょう。 filterdMediumCategory を以下のように修正してください filterdMediumCategory: function () { if (this.lergeCategoryCode === '') { return this.mediumCategoryList } return this.mediumCategoryList.filter((row) => { return row.parentCode === this.lergeCategoryCode }) } 修正した filterdMediumCategory によってヘッダーの中分類選択肢リストが、大分類リストの選択値によって、フィルタリングがかかるようになりました。 大分類で「周辺機器」を選択すると、中分類リストが「ノートパソコン」「デスクトップパソコン」「ディスプレイ」に絞り込まれます。 3.computedのおさらい 業務において、今回のようにデータに何かしらの処理を加えてから表示させたい。という場面があると思います。 そんな時に使えるのがcomputedプロパティです。 computedは一度計算後、同じ処理が呼び出された際も以前計算時にキャッシュされたデータを即時返すだけなので何度も同じ処理を行いません。 キャッシュが削除され再度計算されるのは、依存するデータの値が更新されたときだけです。 (今回でいうと大分類が選択し直されるタイミングで再計算されます) methodsは結果をキャッシュしないので、一度計算を行った場合でも、呼び出されるたびに再計算が行われます。 4.computedとwatchの違いのおさらい watchって？ 特定のデータまたは computed プロパティの状態を監視して、変化があったとき登録した処理を自動的に実行するものです。 データの変更を監視して、それをトリガーに処理を行う必要がある時に使えます。 具体的には ・computed プロパティでは処理できない非同期通信などの複雑な処理を行う場合 ・処理の中で更新前と更新後の値を使う場合 ・処理を実行しても、データは返さない場合 上記にあたる場合はwatchを使って処理をすることが望ましいでしょう。 次の手順では、商品検索画面の修正を行います！ "},"item_search.html":{"url":"item_search.html","title":"アプリケーションコード修正(商品検索画面)","keywords":"","body":"アプリケーションコード修正(商品検索画面) 当手順では、以下の赤枠部分を実施します。 1.当画面に関連するソースファイル src\\views\\itemSearch.vue←修正対象 修正する前に一度、状況を確認してみましょう。 http://localhost:8080/ 画面としては、「商品検索画面」と表示されるのみで、商品一覧は検索されていないことがわかります。 確認できたところで、あらためて修正をすすめていきましょう！ created を使って画面初期表示時の処理を実装しよう。 Ctrl+P(MACの場合Command＋P) を押下してファイル検索を表示し、「itemSearch.vue」を開く Ctrl ＋ F(MACの場合Command+F) で検索欄を表示し、「created」内に初期表示時の処理を記述する。今回は、クエリパラメータを受け取って検索処理を行う「search()」を初期表示時に実行するようにしてみます。 created を以下のように修正してください 変更前 created: function () { // 初期表示時処理 console.log('created') }, 変更後 created: function () { // 初期表示時処理 console.log('created') this.search() }, 初期表示時にsearch()メソッドを呼び出すことによって、画面初期表示時に商品一覧の検索処理が行われるようになりました！ 大分類、中分類を選択したり、検索ワードを入れて検索ボタンを押下すると、絞り込まれたリストが表示されます。 created の処理についておさらい createdは画面初期表示時に走る処理です。正確に言うとインスタンスが生成され､データが初期化された後に実行されます。 初期表示時のデータ初期化後に実施したい処理がある場合はこの中に処理をかいていくことで実現することができます。 今回の場合は画面が初期表示される際に検索処理を行いたかったため、searchメソッドを呼び出すように変更しました。 createdは実際の開発でもよく使うライフサイクルフックの一つですので、ぜひ覚えておいてください！ mountedとの違い createdとmountedは共に画面初期表示時に走る処理です。では何が違うのでしょうか。 mountedは、インスタンスが DOM 要素にマウントされた後に実行される処理です。 getElementById等を使ってDOM要素にアクセスをしたい場合は、mountedに書くことが望ましいです。 createdの時にgetElementById('hoge')でDOMの要素を取得しようとしても取得することはできません。 mountedが実行されるタイミングではDOMの作成が完了しているのでDOMの要素が取得できるため getElementByIdだけではなくDOMに対してアクセスを行う「jQuery」もmounted時点で使用可能となります。 mountedも、createdと並んでよく使うライフサイクルフックです。 初期表示処理はmountedでまとめて行う。という現場も多いです。(厳密に言うと、上記のように使い分けをすべきではあります。) 次の画面では、商品詳細画面の修正を行います！検索結果一覧表示されている商品画像の何れかをクリックし、商品詳細画面へ移動しましょう！ "},"item_detail.html":{"url":"item_detail.html","title":"アプリケーションコード修正(商品情報詳細画面)","keywords":"","body":"商品をカートに入れる機能を実装する(Vuex) 修正対象のソース src/store/index.js src/views/detailView.vue 続いては商品詳細画面です。 この画面は、検索画面で選択した商品の詳細情報が掲載されています。またこの画面でポイントとなるのはカートに入れる機能です。 VuexのStore機能修正 src/store/index.js←今回修正する箇所 今回はVuexというライブラリを使用して、商品をカートに入れます。 \"Vuex\"とはVue.js アプリケーションのための 状態管理パターン + ライブラリです。 https://vuex.vuejs.org/ja/ (Vue.js公式サイトより) VuexをVue.jsで使用する際はVue.use(Vuex)で宣言し、Storeを定義します。 storeとは基本的にアプリケーションの状態（state）を保持するコンテナのようなものです。 今回は既にstoreを宣言している状態で始めます。 storeの宣言で、state・getters・mutations・actionsという項目がありますが、これらはStoreが保持するデータ項目や、Store上のデータを他のソースから操作するための関数を定義する項目です。 storeの４つの機能 state: アプリケーション全体の状態を保持する役割を果たす getter: ストアのステートを取得するための算出データ mutation: stateの値を更新する為に使用される action: 非同期処理や外部APIとの通信を行う役割を果たす 下記図は公式サイトに掲載されているイメージ図です。 簡単に説明すると下記のような流れになります。 ①Componentから、Vuexで定義したactionを呼び出す（Dispatchする） ②DispatchされたactionはAPIを通じて、サーバー側で何らかの処理をする ③サーバー側で返却されたデータをmutationへ送る（Commit） ④mutationがstateを変更する（Mutate） ⑤更新（Mutate）されたstateを、Component側に描画する（Render） 今回actionsは使用しませんが、Vuexの基本的な情報なので覚えておきましょう。 では、実際に修正してましょう。今回修正する箇所は\"src/store/index.js\"の\"mutation\"の箇所です。ここの処理がカートを入れる機能(stateに情報を保持)となります。 変更前 mutations: { // 商品削除 deleteItem (state, item) { // 引数で渡された行を削除 state.itemList.splice(item, 1) }, // 商品リスト初期化 clearItem (state) { state.itemList = [] } } 変更後 18行目のmutationsの下に商品追加のソースを追加してください。 mutations: { // 商品追加 pushItem (state, item) { // 引数で渡された配列をまるごとpush state.itemList.push(item) }, // 商品削除 deleteItem (state, item) { // 引数で渡された行を削除 state.itemList.splice(item, 1) }, // 商品リスト初期化 clearItem (state) { state.itemList = [] } } mutationは上記記載の通りに、stateの値(今回の場合は1件分の商品情報をリストに追加しています)を更新することができます。 pushItemはカートボタンをクリック時に使用し、これで商品情報を保持することができます。これはdetailView.vueでも使用するので、覚えておきましょう。 他にも商品削除のdeleteItemなどありますが、こちらは次の章のカート画面上で使用します。 カートに入れる機能修正 src/views/detailView.vue←今回修正するファイル ここでは、商品検索で選択した商品情報をカートに入れる処理を追加します。 methodの中にあるadditemを下記のように修正してみましょう。 変更前 addItem () { // storeに保存後ダイアログ表示して検索画面へ戻る this.$swal({ title: '完了', icon: 'success', text: 'カートへ追加しました。', type: 'success', confirmButtonText: 'OK' }).then((info) => { this.$router.push({ path: '/' }) }) } 変更後 104行目の addItemの下に商品情報を保持するためのソースを追加してください。 addItem () { // storeに保存後ダイアログ出して検索画面に戻る const param = { name: this.productName, description: this.description, price: this.price, quantity: Number(this.quantity), imageUrl: this.img // 商品画像 } this.$store.commit('pushItem', param) console.log(this.$store.getters.getItemList) // storeに保存後ダイアログ表示して検索画面へ戻る this.$swal({ title: '完了', icon: 'success', text: 'カートへ追加しました。', type: 'success', confirmButtonText: 'OK' }).then((info) => { this.$router.push({ path: '/' }) }) } まず画面に表示されている商品のパラメーターをオブジェクトparamに設定します。それぞれ商品名・商品説明・値段・数量・商品画像の値です。 次に商品のパラメーターのデータを保持をしていきます。書き方としては、this.$store.commitでstoreのstateの値を変更します。 第一引数をstore/index.jsのmutationsに追加したpushItemにします。第二引数は商品情報を代入した変数paramにし、カートボタンを押した際はstore/index.jsのstateのitemListに情報が保持された状態になります。 次の章でのカート画面ではstoreの保持しているStateのitemListをgettersを使用して、表示されることになります。 動作確認 動作確認をしてみましょう。 プルダウンで任意の商品数を選択肢し、商品を購入のボタンをクリックしてください。 下記のように完了のダイアログが表示され検索画面に遷移すれば成功です。 次の章では選択した個数と商品は本当にカートに入っているか確認してみましょう。 また商品を削除するのにもVuexが使用されております。 mutationsに既にあったdeleteItemとclearItemです。deleteItemはカートに入った商品を削除する時に、clearItemは商品を注文した時に使用します。 "},"cart.html":{"url":"cart.html","title":"アプリケーションコード修正(カート画面)","keywords":"","body":"Vue.jsの機能を活用してコードの修正をしてみよう 修正対象のソース client/ecsite/src/views/Cart.vue 既存コードの問題確認 カート画面上に商品詳細画面でカートに追加した商品が表示されています。画面右側に商品の合計値が表示されていますね。カートに入っている商品を削除してみると動的に合計額が変更されるのを確認できると思います。しかし、カート画面のソースを確認すると mounted の際にもhandleDelete method 内にも合計値取得処理（this.getTotal())が記載されていています。これだと処理の実行箇所がまとまっておらずさらに削除ボタンのクリックイベントごとに毎回実行されることになってしまいますね・・・ mounted: function () { // DOMのマウント終了後の処理 /** 合計値取得処理 */ this.totalPrice = this.getTotal() }, methods: { /** * 削除ボタン押下 */ handleDelete (index) { // storeから該当商品を削除 this.$store.commit('deleteItem', index) /** 合計値取得処理 */ this.totalPrice = this.getTotal() }, /** *合計値取得 */ getTotal () { let price = 0 this.getItemList.forEach(element => { price += element.price * element.quantity }) return price } }, 今まで登場したVueの機能を使えば削除ボタンのクリックイベント発火時に毎回合計値取得処理を行う必要がなくなります。ここで今日のハンズオン参加者の皆様にクイズです。ここで利用するべきVue.jsの機能とは一体何でしょうか？ created mounted computed皆さん、考えてみましょう！ "},"cart_answer.html":{"url":"cart_answer.html","title":"アプリケーションコード修正(カート画面) 回答編","keywords":"","body":"Vue.jsの機能を活用してコードの修正をしてみよう 回答編 修正対象のソース client/ecsite/src/views/Cart.vue それでは答え合わせしてみましょう！今回使用するVue.jsの機能は「computed」になります！皆さん予想はどうでしたでしょうか？Vue.jsの機能を把握していないと難しいですよね？早速ですが「computed」を使って画面の修正を行ってみましょう！ Vueの機能を使ってソースコードの修正 mounted と handleDelete method から合計値取得処理を削除して、getTotal method を computed内に書き換えます。 修正前 mounted mounted: function () { // DOMのマウント終了後の処理 /** 合計値取得処理 */ this.totalPrice = this.getTotal() }, methods methods: { getPrice (price, quantity) { return Number(price * quantity) }, /** * 削除ボタン押下 */ handleDelete (index) { // storeから該当商品を削除 this.$store.commit('deleteItem', index) /** 合計値取得処理 */ this.totalPrice = this.getTotal() }, } computed computed: { getItemList () { return this.$store.getters.getItemList } }, 修正後mounted mounted: function () { // DOMのマウント終了後の処理 }, methods methods: { /** * 削除ボタン押下 */ handleDelete (index) { // storeから該当商品を削除 this.$store.commit('deleteItem', index) }, computed computed: { getItemList () { return this.$store.getters.getItemList }, getTotal () { 　　let price = 0 　　this.getItemList.forEach(element => { 　　price += element.price * element.quantity 　　}) 　　return price } }, dataに定義していた totalPrice も削除。templateタグ内で合計額表示している箇所を computed に定義した getTotal に書き換えます。 修正前 ￥{{ totalPrice | money }}円 商品を購入 修正後 ￥{{ getTotal | money }}円 商品を購入 修正内容の確認 ブラウザをリロードしてみて表示されている内容に問題がないか確認してみましょう。ソースコード上ではVueの機能を使うことでロジックがまとまり、保守の観点でも修正箇所が減って可読性も上がりました。画面上では修正前と同じく商品の削除ボタンが押下されたたびに合計額が動的に変化するのが確認できると思います。 "},"cleanup.html":{"url":"cleanup.html","title":"local環境のCleanUp","keywords":"","body":"local環境のCleanUp 今回のハンズオンで使用した開発環境の削除を行います。 コンテナの停止以下コマンドでDockerコンテナを停止します。 $ docker-compose down コンテナが停止しているか確認します。 $ docker-compose ps Name Command State Ports ------------------------------ イメージの削除 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE mirameetvol29_server latest ba2bac2d2844 4 days ago 197MB mirameetvol29_client latest 05b82c10dc6e 6 days ago 111MB 上記で確認できたIMAGE IDを利用して、ビルドされたイメージを削除します。 docker rmi -f [IMAGE ID] 次のようなメッセージが確認できたら、イメージが正常に削除出来ています。 Untagged: meetup_web... フォルダの削除最後にフォルダを削除します。 3.1. Macの場合 # 一つ上の階層に移動 cd ../ # xxxxxxxxxxxフォルダが存在しているかを確認 ls # xxxxxxxxxxxフォルダが存在している場合、下記コマンドを実行しフォルダを削除 rm -rf xxxxxxxxx 3.2. Windowsの場合 # 一つ上の階層に移動 cd ../ # xxxxxxxxxxxフォルダが存在しているかを確認 dir # xxxxxxxxxxxフォルダが存在している場合、下記コマンドを実行しフォルダを削除 rd /s /q xxxxxxxxxx # PowerShellをご使用の方はこちらのコマンドをご使用下さい Remove-Item xxxxxxxxxx -Recurse -Force 以上で本日のハンズオンは終了となります。皆様お疲れ様でした！ "}}