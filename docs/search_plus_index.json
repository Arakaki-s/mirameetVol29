{"./":{"url":"./","title":"はじめに","keywords":"","body":"mirameet vol.31_Vue.js　現場で役立つ実践Vue.js!～ECサイトを作成してみる～ 事前準備 VSCodeインストール Dockerインストール 今回の流れ 以下内容についてハンズオンしていきます。 商品検索の共通ヘッダーを実装してみる（component） 商品検索画面の初期表示処理を実装してみる（created, mounted） 商品をカートに入れる機能を実装する（VueX） 商品の合計金額を自動で算出する（computed） 手順 環境構築①：デモアプリクローン 環境構築②：デモアプリの起動、動作確認 アプリケーションコード修正（商品検索画面） アプリケーションコード修正（商品詳細画面） アプリケーションコード修正（カート画面） 作成したコンテナの削除 "},"create_env_no1.html":{"url":"create_env_no1.html","title":"環境構築 1","keywords":"","body":"環境構築 その１ Django APIサーバーをDocker環境で準備 はじめに今回のハンズオンの環境構築を行いたいと思います。まずは、Vueの環境を立てる前にサーバーサイドとして使用するDjangoフレームワークを用いてAPIサーバーを準備します。 vscodeの拡張機能の確認 vscodeの拡張機能で、「ESLint」「Vetur」が入っているか確認してください。拡張機能を開く「ESLint」「Vetur」をインストールされいてるか確認する。まだの場合はインストールする。ESLint 保存時に自動フォーマットしたり、コードの構文チェックをしてくれる。 Vetur vue.jsでシンタックスハイライトしてくれる。vscodeでvue.jsを扱うならほぼ必須。インストールした場合は、vscodeを一度閉じて、再起動してください。 githubリポジトリにアクセス 以下リンクよりデモアプリのあるGithubリポジトリにアクセスします。URL:https://github.com/miracleave-ltd/mirameetVol31-Vue.js ソースコードダウンロード Codeボタンより、Zipファイルをダウンロードします。 ソースコード展開 ダウンロードしたZipファイルを任意のフォルダに展開してください。※次の手順を進めるに当たり、展開されたフォルダをVSCodeで開くようお願いします。ファイル フォルダーを開くclient > ecsiteを選択して開く サーバーの起動 一度ローカルでサーバーを立ち上げましょう。 5-1. Docker Desktopの起動確認 docker Desktopが起動できていることを確認します 5-2. Dockerのbuildと起動の確認 コマンドをVSCodeのターミナル上から実施し、Dockerの起動を行います。 ターミナル > 新しいターミナル 以下コマンドでdocker-compose.ymlがあるフォルダに階層を移動します。 cd ../../ 以下コマンドを実行し、コンテナをビルドします。 docker-compose up -d --build dockerが起動しているか以下のコマンドで確認してみましょう。 docker-compose ps Name Command State Ports -------------------------------------------------------------------------------------------------- mirameet_vol30_20220314_client_1 docker-entrypoint.sh node Up 0.0.0.0:8080->8080/tcp mirameet_vol30_20220314_server_1 python manage.py runserver ... Up 0.0.0.0:8040->8000/tcp state が Up となっていれば問題ありません。 "},"create_env_no2.html":{"url":"create_env_no2.html","title":"環境構築 2","keywords":"","body":"環境構築 その2 Vue アプリケーションをDocker環境で準備 続いてVueアプリケーションの準備に移ります。 ecsiteディレクトリ直下をvscodeで開いていることを確認してください。vscodeが正常に動作しないことがあります。以下がecsiteディレクトリになります。 mirameetVol31.-main/client/ecsite Dockerコンテナに入ってnpm installを実行 Vueプロジェクトに必要なパッケージをインストールするためにまずは下記のコマンドでDockerコンテナに入ります。 docker-compose exec client sh Dockerコンテナ内に入ったらnpmでvue/cliをインストールします。ターミナル上に /usr/src と表示されていればコンテナに入れています。 npm install -g @vue/cli 続いて、以下コマンドでnode_modulesフォルダ上に必要なパッケージ類がインストールされます。(通信環境によってしばらく時間がかかります。) npm install Vueアプリケーションサーバーをたてる npmでパッケージインストールが完了したら引き続きDocker内で以下コマンドでVueアプリケーションを立てましょう。ビルドには少々時間がかかります。 npm run serve 以下の表示になったら起動完了です。 ブラウザから起動確認をしましょう。 2 の実装が完了したら以下のURLでブラウザ上から起動の確認を行ってください。url: http://localhost:8080 "},"component.html":{"url":"component.html","title":"コード修正(App.vue)","keywords":"","body":"アプリケーションコード修正(コンポーネント) 当手順では、以下の赤枠部分を実施します。 1.当画面に関連するソースファイル src\\App.vue←修正対象 src\\components\\Header.vue src\\router\\index.js 修正する前に一度、状況を確認してみましょう。 http://localhost:8080/ 画面としては何もない状態であることがわかったかと思います。 確認できたところで、あらためて修正をすすめていきましょう！ 2.src\\App.vueの修正 vueファイルは主に ・templateタグ：html要素を記述する ・scriptタグ：javascriptの処理を記述する ・styleタグ：cssを記述する の三つのタグからなります。 これらを合わせて一つのコンポーネントとして作成し、 それら組み合わせて1つのページを作るのがVue.jsの大枠の考え方です。 コンポーネントを呼び出すにはまずscriptタグ内で呼び出すコンポーネントのvueファイルをインポートし、 components要素内に使用するコンポーネント名を記載します。 その後templateタグ内で、呼び出すコンポーネント名をそのままタグとして記載してあげれば、その場所に子コンポーネントが挿入されます。 ヘッダーをインポートして画面に配置しよう。 src\\App.vue にヘッダー用のコンポーネントをインポートし、画面上に配置します。 Ctrl+P(MACの場合Command+P) を押下してファイル検索を表示し、「App.vue」を開く ソースを以下のように修正してください。修正したら、ファイルを上書き保存してください。 修正前 export default { name: 'App', components: { } } 修正後 // Header.vueをインポート import Header from './components/Header' // components にHeader追加する export default { name: 'App', components: { Header } } 画面上部にヘッダーが実装できました。 補足:ルーティングの説明 app.vueの以下の部分(Vue Router) Vue Routerとは、 Vue.jsを利用したSPA構築で、ルーティング制御をするための公式プラグインです src\\router\\index.js内に、アプリケーションのルーティングを記述しています。 import Vue from 'vue' import VueRouter from 'vue-router' import itemSearch from '../views/itemSearch.vue' import Cart from '../views/Cart.vue' import DetailView from '../views/detailView.vue' Vue.use(VueRouter) const routes = [ { path: '/', name: 'home', component: itemSearch }, { path: '/cart', name: 'cart', component: Cart }, { path: '/detail', name: 'detail', component: DetailView } ] const router = new VueRouter({ mode: 'history', base: process.env.BASE_URL, routes }) export default router pathに書かれたURLにアクセスすると、componentに設定されたページ内容を 「router-view」のエリアで表示します。 今回の場合は上記記述によって、ヘッダーは常に共通のものが表示、URLが変更されると 「router-view」の内容がそのURLに設定されたページを表示してくれます。 次の手順では、ヘッダー内の修正を行っていきます！ "},"header.html":{"url":"header.html","title":"コード修正(ヘッダー)","keywords":"","body":"アプリケーションコード修正(ヘッダー) 当手順では、以下の赤枠部分を実施します。 1.当画面に関連するソースファイル src\\components\\Header.vue←修正対象 修正する前に一度、状況を確認してみましょう。 http://localhost:8080/ 「大分類」から、何か選択した状態で「中分類」のリストをクリックしてみてください。 特にフィルタリング処理は実装されておらず、大分類を変更しても中分類リストの選択肢一覧に変更がないことが分かったかと思います。 2.computedのおさらい 業務において、データに何かしらの処理を加えてから表示させたい。という場面があると思います。 そんな時に使えるのがcomputedプロパティです。 computedは一度計算後、同じ処理が呼び出された際も以前計算時にキャッシュされたデータを即時返すだけなので何度も同じ処理を行いません。 キャッシュが削除され再度計算されるのは、依存するデータの値が更新されたときだけです。 methodsは結果をキャッシュしないので、一度計算を行った場合でも、呼び出されるたびに再計算が行われます。 3.computedとwatchの違いのおさらい watchって？ 特定のデータまたは computed プロパティの状態を監視して、変化があったとき登録した処理を自動的に実行するものです。 データの変更を監視して、それをトリガーに処理を行う必要がある時に使えます。 具体的には ・computed プロパティでは処理できない非同期通信などの複雑な処理を行う場合 ・処理の中で更新前と更新後の値を使う場合 ・処理を実行しても、データは返さない場合 上記にあたる場合はwatchを使って処理をすることが望ましいでしょう。 4.src\\components\\Header.vueの修正 computed を使ってフィルタリング処理を実装しよう。 おさらいを確認したうえで、、あらためて修正をすすめていきましょう！ Ctrl+P(MACの場合Command+P) を押下してファイル検索を表示し、「Header.vue」を開く Ctrl+F(MACの場合Command＋F) で検索欄を表示し、「filterdMediumCategory」内にフィルタリング処理を記述する。中分類リストの選択肢内容を、大分類の選択値に基づいて動的にフィルタリング処理をかけてみましょう。 filterdMediumCategory を以下のように修正してください filterdMediumCategory: function () { if (this.lergeCategoryCode === '') { return this.mediumCategoryList } return this.mediumCategoryList.filter((row) => { return row.parentCode === this.lergeCategoryCode }) } 修正した filterdMediumCategory によってヘッダーの中分類選択肢リストが、大分類リストの選択値によって、フィルタリングがかかるようになりました。 大分類で「周辺機器」を選択すると、中分類リストが「ノートパソコン」「デスクトップパソコン」「ディスプレイ」に絞り込まれます。 次の手順では、商品検索画面の修正を行います！ "},"item_search.html":{"url":"item_search.html","title":"コード修正(商品検索)","keywords":"","body":"アプリケーションコード修正(商品検索画面) 当手順では、以下の赤枠部分を実施します。 1.当画面に関連するソースファイル src\\views\\itemSearch.vue←修正対象 修正する前に一度、状況を確認してみましょう。 http://localhost:8080/ 画面としては、「商品検索画面」と表示されるのみで、商品一覧は検索されていないことがわかります。 確認できたところで、あらためて修正をすすめていきましょう！ created を使って画面初期表示時の処理を実装しよう。 Ctrl+P(MACの場合Command＋P) を押下してファイル検索を表示し、「itemSearch.vue」を開く Ctrl ＋ F(MACの場合Command+F) で検索欄を表示し、「created」内に初期表示時の処理を記述する。今回は、クエリパラメータを受け取って検索処理を行う「search()」を初期表示時に実行するようにしてみます。 created を以下のように修正してください 変更前 created: function () { // 初期表示時処理 console.log('created') }, 変更後 created: function () { // 初期表示時処理 console.log('created') this.search() }, 初期表示時にsearch()メソッドを呼び出すことによって、画面初期表示時に商品一覧の検索処理が行われるようになりました！ 大分類、中分類を選択したり、検索ワードを入れて検索ボタンを押下すると、絞り込まれたリストが表示されます。 created の処理についておさらい createdは画面初期表示時に走る処理です。正確に言うとインスタンスが生成され､データが初期化された後に実行されます。 初期表示時のデータ初期化後に実施したい処理がある場合はこの中に処理をかいていくことで実現することができます。 今回の場合は画面が初期表示される際に検索処理を行いたかったため、searchメソッドを呼び出すように変更しました。 createdは実際の開発でもよく使うライフサイクルフックの一つですので、ぜひ覚えておいてください！ mountedとの違い createdとmountedは共に画面初期表示時に走る処理です。では何が違うのでしょうか。 mountedは、インスタンスが DOM 要素にマウントされた後に実行される処理です。 getElementById等を使ってDOM要素にアクセスをしたい場合は、mountedに書くことが望ましいです。 createdの時にgetElementById('hoge')でDOMの要素を取得しようとしても取得することはできません。 mountedが実行されるタイミングではDOMの作成が完了しているのでDOMの要素が取得できるため getElementByIdだけではなくDOMに対してアクセスを行う「jQuery」もmounted時点で使用可能となります。 mountedも、createdと並んでよく使うライフサイクルフックです。 初期表示処理はmountedでまとめて行う。という現場も多いです。(厳密に言うと、上記のように使い分けをすべきではあります。) 次の画面では、商品詳細画面の修正を行います！検索結果一覧表示されている商品画像の何れかをクリックし、商品詳細画面へ移動しましょう！ "},"item_detail.html":{"url":"item_detail.html","title":"コード修正(商品情報詳細)","keywords":"","body":"商品をカートに入れる機能を実装する(Vuex) 修正対象のソース src/store/index.js src/views/detailView.vue 続いては商品詳細画面です。 この画面は、検索画面で選択した商品の詳細情報が掲載されています。またこの画面でポイントとなるのはカートに入れる機能です。 store/index.jsにカートに追加するための機能を実装する。 src/store/index.js←今回修正する箇所 修正する前に一度、状況を確認してみましょう。http://localhost:8080/detail?itemCode=2商品の個数を選択して、カートに入れるボタンを押下してみてください。「カートに追加しました。」というダイアログが出て、OKボタンを押下すると検索画面へ戻ります。 では、この状態でカート画面へ遷移してみましょう。http://localhost:8080/cart先ほどカートに商品を追加したはずですが、カート画面を開いてみても、何も表示されません。 確認できたところで、改めて修正を進めていきましょう。 今回はVuexというライブラリを使用して、商品をカートに入れます。 \"Vuex\"とはVue.js アプリケーションのための 状態管理パターン + ライブラリです。 https://vuex.vuejs.org/ja/ (Vue.js公式サイトより) では、実際に修正してましょう。今回修正する箇所は\"src/store/index.js\"の\"mutations\"の箇所です。今回は、mutetionsにカートに入れるボタンを押下した際に、商品情報を保持するための処理を追加します。 変更前 mutations: { // 商品削除 deleteItem (state, item) { // 引数で渡された行を削除 state.itemList.splice(item, 1) }, // 商品リスト初期化 clearItem (state) { state.itemList = [] } } 変更後 18行目のmutationsの下に商品追加のソースを追加してください。 mutations: { // 商品追加 pushItem (state, item) { // 引数で渡された配列をまるごとpush state.itemList.push(item) }, // 商品削除 deleteItem (state, item) { // 引数で渡された行を削除 state.itemList.splice(item, 1) }, // 商品リスト初期化 clearItem (state) { state.itemList = [] } }, pushItemはカートボタンをクリック時に使用し、これで商品情報を保持させることができますこの処理はこの後detailView.vueの修正でも使用します。他にも商品削除のdeleteItemなどありますが、こちらは次の章のカート画面上で使用します。商品をカートの保持情報から削除するための処理になります。 views/detailView.vueにカートに入れる機能を追加する。 src/views/detailView.vue←今回修正するファイル ここでは、商品検索で選択した商品情報をカートに入れる処理を追加します。 methodsの中にある「additem」の処理を下記のように修正してみましょう。 変更前 addItem () { // storeに保存後ダイアログ表示して検索画面へ戻る this.$swal({ title: '完了', icon: 'success', text: 'カートへ追加しました。', type: 'success', confirmButtonText: 'OK' }).then((info) => { this.$router.push({ path: '/' }) }) } 変更後 104行目の addItemの下に商品情報を保持するためのソースを追加してください。 addItem () { // storeに保存後ダイアログ出して検索画面に戻る const param = { name: this.productName, description: this.description, price: this.price, quantity: Number(this.quantity), imageUrl: this.img // 商品画像 } this.$store.commit('pushItem', param) // storeに保存後ダイアログ表示して検索画面へ戻る this.$swal({ title: '完了', icon: 'success', text: 'カートへ追加しました。', type: 'success', confirmButtonText: 'OK' }).then((info) => { this.$router.push({ path: '/' }) }) } まず画面に表示されている商品のパラメーターをオブジェクトparamに設定します。それぞれ商品名・商品説明・値段・数量・商品画像です。 次に先ほど追加した「pushItem」を呼び出して商品情報をstoreに追加します。書き方としては、this.$store.commit('呼び出す処理名',処理に渡す引数)でstoreのstateの値を変更します。第一引数をstore/index.jsのmutationsに追加したpushItemにします。第二引数は商品情報をもった変数paramすることで、store/index.jsのstateのitemListに商品情報を追加します。 カート画面ではstoreの保持しているitemListをgettersを使用して、カート画面上に表示されることになります。 動作確認 動作確認をしてみましょう。 プルダウンで任意の商品数を選択肢し、商品を購入のボタンをクリックしてください。 下記のように完了のダイアログが表示され検索画面に遷移します。商品がカートに入っているか確認してみましょう。画面右上のショッピングカートのアイコンをクリックすることで、カート画面へ遷移します。カートに入れた商品が表示されることがわかるかと思います。 また商品を削除するのにもVuexが使用されております。 mutationsに既にあったdeleteItemとclearItemです。deleteItemはカートに入った商品を削除する時に、clearItemは商品を注文した時に使用します。 "},"cart.html":{"url":"cart.html","title":"コード修正(カート)","keywords":"","body":"Vue.jsの機能を活用してコードの修正をしてみよう 修正対象のソース client/ecsite/src/views/Cart.vue 既存コードの問題確認 カート画面上に商品詳細画面でカートに追加した商品が表示されています。画面右側に商品の合計値が表示されていますね。カートに入っている商品を削除ボタンで削除してみると、合計額が変更されるのを確認できると思います。カート画面のソースを確認すると mounted の際にもhandleDelete method 内にも合計値取得処理（this.getTotal())が記載されています。 mounted: function () { // DOMのマウント終了後の処理 /** 合計値取得処理 */ this.totalPrice = this.getTotal() }, methods: { /** * 削除ボタン押下 */ handleDelete (index) { // storeから該当商品を削除 this.$store.commit('deleteItem', index) /** 合計値取得処理 */ this.totalPrice = this.getTotal() }, /** *合計値取得 */ getTotal () { let price = 0 this.getItemList.forEach(element => { price += element.price * element.quantity }) return price } }, 今まで登場したVue.jsの機能を使えば削除ボタンのクリックイベント発火時に毎回合計値取得処理を明示的に呼び出す必要がなくなります。ここで今日のハンズオン参加者の皆様にクイズです。ここで利用するべきVue.jsの機能とは一体何でしょうか？ created mounted computed皆さん、考えてみましょう！ "},"cart_answer.html":{"url":"cart_answer.html","title":"コード修正(カート) 回答","keywords":"","body":"Vue.jsの機能を活用してコードの修正をしてみよう 回答編 修正対象のソース client/ecsite/src/views/Cart.vue それでは答え合わせしてみましょう！今回使用するVue.jsの機能は「computed」になります！皆さん予想はどうでしたでしょうか？早速ですが「computed」を使って画面の修正を行ってみましょう！ ソースコードの修正 mounted と handleDelete から合計値取得処理を削除して、getTotal method を computed内に書き換えます。 修正前 mounted mounted: function () { // DOMのマウント終了後の処理 /** 合計値取得処理 */ this.totalPrice = this.getTotal() }, methods getPrice (price, quantity) { return Number(price * quantity) }, /** * 削除ボタン押下 */ handleDelete (index) { // storeから該当商品を削除 this.$store.commit('deleteItem', index) /** 合計値取得処理 */ this.totalPrice = this.getTotal() }, /** *合計値取得 */ getTotal () { let price = 0 this.getItemList.forEach(element => { price += element.price * element.quantity }) return price }, computed computed: { getItemList () { return this.$store.getters.getItemList } }, 修正後mountedthis.totalPrice = this.getTotal()を削除 mounted: function () { // DOMのマウント終了後の処理 }, methodsgetTotal()メソッドを削除。 getPrice (price, quantity) { return Number(price * quantity) }, /** * 削除ボタン押下 */ handleDelete (index) { // storeから該当商品を削除 this.$store.commit('deleteItem', index) /** 合計値取得処理 */ this.totalPrice = this.getTotal() }, computedgetTotal()処理を追加 computed: { getItemList () { return this.$store.getters.getItemList }, getTotal () { 　　let price = 0 　　this.getItemList.forEach(element => { 　　price += element.price * element.quantity 　　}) 　　return price } }, templateタグ内で合計額表示している箇所の「totalPrice」をcomputed に定義した 「getTotal」 に書き換えます。 修正前 ￥{{ totalPrice | money }}円 商品を購入 修正後 ￥{{ getTotal | money }}円 商品を購入 修正内容の確認 ブラウザをリロードしてみて表示されている内容に問題がないか確認してみましょう。機能としては、修正前と同じく、商品をカートから削除した際に合計額が再計算されます。ソースコード上では色々な場所から同じ処理を呼び出す事がなくなり、保守の観点でも修正箇所が減って可読性も上がりました。このように、プログラムの外部から見た動作を変えずにソースコードの内部構造を整理することを「リファクタリング」と言います。実務においてもリファクタリングを行う場面は多々あると思います。ぜひ覚えておいてください！ "},"cleanup.html":{"url":"cleanup.html","title":"local環境のCleanUp","keywords":"","body":"local環境のCleanUp 今回のハンズオンで使用した開発環境の削除を行います。 コンテナの停止以下コマンドでDockerコンテナを停止します。 $ docker-compose down コンテナが停止しているか確認します。 $ docker-compose ps Name Command State Ports ------------------------------ イメージの削除 $ docker images REPOSITORY TAG IMAGE ID CREATED SIZE mirameetvol29_server latest ba2bac2d2844 4 days ago 197MB mirameetvol29_client latest 05b82c10dc6e 6 days ago 111MB 上記で確認できたIMAGE IDを利用して、ビルドされたイメージを削除します。 docker rmi -f [IMAGE ID] 次のようなメッセージが確認できたら、イメージが正常に削除出来ています。 Untagged: meetup_web... フォルダの削除最後にフォルダを削除します。 3.1. Macの場合 # 一つ上の階層に移動 cd ../ # xxxxxxxxxxxフォルダが存在しているかを確認 ls # xxxxxxxxxxxフォルダが存在している場合、下記コマンドを実行しフォルダを削除 rm -rf xxxxxxxxx 3.2. Windowsの場合 # 一つ上の階層に移動 cd ../ # xxxxxxxxxxxフォルダが存在しているかを確認 dir # xxxxxxxxxxxフォルダが存在している場合、下記コマンドを実行しフォルダを削除 Remove-Item xxxxxxxxxx -Recurse -Force 以上で本日のハンズオンは終了となります。皆様お疲れ様でした！ "}}